---
phase: 03-performance
plan: 01
type: execute
wave: 1
depends_on: []
files_modified: []
autonomous: true
---

<objective>
Profile QuickLook preview performance to identify the exact bottleneck causing 1-2 second delays for 10-30KB files.

Purpose: Evidence-based optimization - confirm whether JavaScript bridge (HighlightSwift) is the bottleneck before investing in alternatives.
Output: Profiling results documenting where time is spent, enabling informed decisions for 03-02 and 03-03.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

@QuickLookPreview/PreviewViewController.swift
@QuickLookPreview/PreviewContentView.swift
@Shared/SyntaxHighlighter.swift
@Shared/Logger.swift
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add detailed timing instrumentation to highlighting path</name>
  <files>QuickLookPreview/PreviewContentView.swift</files>
  <action>
Add timing measurements to the `highlightCode()` function to capture:
1. Time before calling SyntaxHighlighter
2. Time after SyntaxHighlighter returns
3. Total highlight duration

Use the existing `DotViewerLogger` with TimingScope or add os.signpost for Instruments compatibility:

```swift
import os.signpost

// In highlightCode():
let signpostID = OSSignpostID(log: .default)
os_signpost(.begin, log: .default, name: "SyntaxHighlight", signpostID: signpostID)
let result = try await highlighter.highlight(code: state.content, language: state.language)
os_signpost(.end, log: .default, name: "SyntaxHighlight", signpostID: signpostID)
```

Also log file size and line count with the timing for correlation analysis.
  </action>
  <verify>Build succeeds: `xcodebuild -project dotViewer.xcodeproj -scheme QuickLookPreview build`</verify>
  <done>Timing instrumentation added to highlight path</done>
</task>

<task type="auto">
  <name>Task 2: Profile with test files and document results</name>
  <files>.planning/phases/03-performance/PROFILING-RESULTS.md</files>
  <action>
1. Build and install the extension: `xcodebuild -project dotViewer.xcodeproj -scheme dotViewer build`
2. Test preview timing with various file sizes using Console.app or Instruments
3. Test files to use:
   - Small: Any 5-10KB source file (e.g., SyntaxHighlighter.swift itself)
   - Medium: 20-30KB file (e.g., PreviewContentView.swift at ~50KB)
   - Control: Same files with highlighting disabled (set language to "plaintext")

4. Document findings in PROFILING-RESULTS.md:
   - Time breakdown by phase (file read, language detection, highlighting, rendering)
   - Correlation between file size and highlight time
   - Comparison with/without highlighting to isolate bottleneck
   - Recommendation for optimization path

Expected finding based on research: HighlightSwift's JavaScript execution will dominate (>80% of total time).
  </action>
  <verify>PROFILING-RESULTS.md exists with timing data</verify>
  <done>Profiling complete with documented evidence of bottleneck location</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] Timing instrumentation compiles without errors
- [ ] PROFILING-RESULTS.md contains quantitative timing data
- [ ] Bottleneck clearly identified with evidence
</verification>

<success_criteria>
- Instrumentation added to measure highlighting time
- Profiling results documented with specific timing data
- Clear evidence of where time is spent (likely JavaScript execution)
- Recommendation documented for optimization approach
</success_criteria>

<output>
After completion, create `.planning/phases/03-performance/03-01-SUMMARY.md`
</output>
