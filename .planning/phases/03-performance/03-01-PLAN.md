# Plan 03-01: Tree-sitter + Neon Integration

## Objective

Replace slow HighlightSwift (JavaScriptCore-based) with fast Tree-sitter + Neon (native Swift) for syntax highlighting. Target: <100ms per file, smooth navigation at 140 BPM.

## Context

- **Problem**: HighlightSwift uses JavaScriptCore + highlight.js, causing 1-2 second delays
- **Previous attempt**: Syntect/Rust via UniFFI — abandoned after 3 failed integration attempts
- **New approach**: Tree-sitter + Neon — all Swift packages, simpler integration
- **Performance target**: <430ms between files (140 BPM navigation)

## References

- [ChimeHQ/SwiftTreeSitter](https://github.com/ChimeHQ/SwiftTreeSitter)
- [ChimeHQ/Neon](https://github.com/ChimeHQ/Neon)
- Current highlighter: `Shared/SyntaxHighlighter.swift`
- Preview view: `QuickLookPreview/PreviewContentView.swift`

## Dependencies

- SwiftTreeSitter (Swift package)
- Neon (Swift package)
- Tree-sitter language parsers (e.g., tree-sitter-swift, tree-sitter-javascript)

## Tasks

### Task 1: Add Swift Package Dependencies

**Files**: `dotViewer.xcodeproj/project.pbxproj`

1. Add SwiftTreeSitter package:
   - URL: `https://github.com/ChimeHQ/SwiftTreeSitter`
   - Version: Latest stable

2. Add Neon package:
   - URL: `https://github.com/ChimeHQ/Neon`
   - Version: Latest stable

3. Add tree-sitter language parsers for top languages:
   - tree-sitter-swift
   - tree-sitter-javascript (covers JS/TS/JSX/TSX)
   - tree-sitter-python
   - tree-sitter-json
   - tree-sitter-yaml
   - tree-sitter-bash (for shell scripts)
   - tree-sitter-go
   - tree-sitter-rust
   - tree-sitter-markdown

4. Link packages to both targets:
   - dotViewer (main app)
   - QuickLookPreview (extension)

**Verification**: Project builds without errors after adding packages.

### Task 2: Create TreeSitterHighlighter

**Files**: `Shared/TreeSitterHighlighter.swift` (new file)

Create a new highlighter using Neon's static highlighting API:

```swift
import Foundation
import SwiftUI
import Neon
import SwiftTreeSitter

struct TreeSitterHighlighter: Sendable {

    /// Highlight code using Tree-sitter + Neon
    /// - Parameters:
    ///   - code: Source code to highlight
    ///   - language: Language identifier (e.g., "swift", "javascript")
    /// - Returns: Attributed string with syntax highlighting
    func highlight(code: String, language: String?) async throws -> AttributedString {
        guard let lang = language,
              let config = languageConfig(for: lang) else {
            // Unknown language - return plain text
            return plainText(code)
        }

        let highlighted = try await TreeSitterClient.highlight(
            string: code,
            attributeProvider: attributeProvider,
            rootLanguageConfig: config,
            languageProvider: { _ in nil }
        )

        return highlighted
    }

    /// Map language string to Tree-sitter configuration
    private func languageConfig(for language: String) -> LanguageConfiguration? {
        // Map language identifiers to tree-sitter parsers
        switch language.lowercased() {
        case "swift":
            return try? LanguageConfiguration(tree_sitter_swift())
        case "javascript", "js", "jsx":
            return try? LanguageConfiguration(tree_sitter_javascript())
        case "typescript", "ts", "tsx":
            return try? LanguageConfiguration(tree_sitter_typescript())
        case "python", "py":
            return try? LanguageConfiguration(tree_sitter_python())
        case "json":
            return try? LanguageConfiguration(tree_sitter_json())
        case "yaml", "yml":
            return try? LanguageConfiguration(tree_sitter_yaml())
        case "bash", "shell", "sh", "zsh":
            return try? LanguageConfiguration(tree_sitter_bash())
        case "go", "golang":
            return try? LanguageConfiguration(tree_sitter_go())
        case "rust", "rs":
            return try? LanguageConfiguration(tree_sitter_rust())
        case "markdown", "md":
            return try? LanguageConfiguration(tree_sitter_markdown())
        default:
            return nil
        }
    }

    /// Provide attributes for syntax tokens based on theme
    private var attributeProvider: TokenAttributeProvider {
        { token in
            // Map token types to colors based on current theme
            let colors = ThemeManager.shared.syntaxColors

            switch token.name {
            case "keyword", "keyword.control", "keyword.operator":
                return [.foregroundColor: colors.keyword]
            case "string", "string.special":
                return [.foregroundColor: colors.string]
            case "comment", "comment.line", "comment.block":
                return [.foregroundColor: colors.comment]
            case "number", "constant.numeric":
                return [.foregroundColor: colors.number]
            case "type", "type.builtin", "support.type":
                return [.foregroundColor: colors.type]
            case "function", "function.method":
                return [.foregroundColor: colors.function]
            case "variable", "variable.parameter":
                return [.foregroundColor: colors.variable]
            default:
                return [.foregroundColor: colors.text]
            }
        }
    }

    private func plainText(_ code: String) -> AttributedString {
        var result = AttributedString(code)
        result.font = .system(size: SharedSettings.shared.fontSize, design: .monospaced)
        result.foregroundColor = ThemeManager.shared.textColor
        return result
    }
}
```

**Verification**: File compiles without errors.

### Task 3: Add Syntax Colors to ThemeManager

**Files**: `Shared/ThemeManager.swift`

Add syntax color properties to ThemeManager:

```swift
/// Syntax highlighting colors for the current theme
var syntaxColors: SyntaxColors {
    switch selectedTheme {
    case "atomOneDark", "blackout":
        return SyntaxColors(
            keyword: NSColor(hex: "#c678dd"),
            string: NSColor(hex: "#98c379"),
            comment: NSColor(hex: "#5c6370"),
            number: NSColor(hex: "#d19a66"),
            type: NSColor(hex: "#e5c07b"),
            function: NSColor(hex: "#61afef"),
            variable: NSColor(hex: "#e06c75"),
            text: NSColor(hex: "#abb2bf")
        )
    // ... other themes
    }
}

struct SyntaxColors {
    let keyword: NSColor
    let string: NSColor
    let comment: NSColor
    let number: NSColor
    let type: NSColor
    let function: NSColor
    let variable: NSColor
    let text: NSColor
}
```

**Verification**: ThemeManager compiles with new properties.

### Task 4: Update SyntaxHighlighter to Use Tree-sitter

**Files**: `Shared/SyntaxHighlighter.swift`

Modify existing SyntaxHighlighter to try Tree-sitter first, fall back to HighlightSwift:

```swift
struct SyntaxHighlighter: Sendable {
    private let treeSitter = TreeSitterHighlighter()
    private let highlight = Highlight() // Keep as fallback

    func highlight(code: String, language: String?) async throws -> AttributedString {
        // Try Tree-sitter first (fast path)
        do {
            return try await treeSitter.highlight(code: code, language: language)
        } catch {
            // Fall back to HighlightSwift for unsupported languages
            return try await highlightWithFallback(code: code, language: language)
        }
    }

    private func highlightWithFallback(code: String, language: String?) async throws -> AttributedString {
        // Existing HighlightSwift implementation
        // ...
    }
}
```

**Verification**: Build succeeds, both highlighters available.

### Task 5: Add Timing Instrumentation

**Files**: `QuickLookPreview/PreviewContentView.swift`

Add timing logs to measure performance:

```swift
private func highlightCode() async {
    let startTime = CFAbsoluteTimeGetCurrent()

    // ... existing highlighting code ...

    let elapsed = (CFAbsoluteTimeGetCurrent() - startTime) * 1000
    Logger.shared.info("Highlighting completed in \(String(format: "%.1f", elapsed))ms")
}
```

**Verification**: Timing appears in Console.app logs.

### Task 6: Performance Verification

**Manual Testing**:

1. Build and run the app
2. Open Console.app, filter for "dotViewer"
3. Navigate to source files with QuickLook (Space key)
4. Observe timing logs
5. Test rapid navigation (arrow keys through files)

**Acceptance Criteria**:
- [ ] Individual file highlighting: <100ms
- [ ] Rapid navigation (140 BPM): Smooth, no visible lag
- [ ] No regressions in highlighting quality

## Rollback Plan

If Tree-sitter integration fails:
1. Revert to HighlightSwift-only implementation
2. Execute 03-02-PLAN.md (Pure Swift pattern highlighter fallback)

## Checkpoints

- [ ] After Task 2: First build with Tree-sitter packages
- [ ] After Task 5: Performance testing ready

## Notes

- Keep HighlightSwift as fallback for languages without tree-sitter parsers
- Tree-sitter parsers are compiled C code wrapped in Swift packages
- Neon's static API is designed for one-shot highlighting (perfect for QuickLook)
