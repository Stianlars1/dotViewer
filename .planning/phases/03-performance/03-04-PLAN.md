---
phase: 03-performance
plan: 04
type: execute
wave: 4
depends_on: ["03-03"]
files_modified: [Shared/SwiftPatternHighlighter.swift, Shared/SyntaxHighlighter.swift]
autonomous: true
condition: "Only execute if 03-03 checkpoint reports 'too slow' or Syntect integration fails"
---

<objective>
CONTINGENCY: Implement pure Swift pattern-based highlighter as fallback.

Purpose: If Syntect/UniFFI integration proves too slow, complex, or problematic, implement a CodeColors-style pure Swift highlighter for instant performance.
Output: Native Swift syntax highlighter covering top 20 languages with <10ms performance.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/03-performance/03-03-SUMMARY.md

Reference: https://github.com/Oil3/CodeColors-Quicklook-Syntax-Highlighting
Reference: https://shadowfacts.net/2020/syntax-highlighting-javascript/

@Shared/LanguageDetector.swift (language mappings)
@Shared/ThemeManager.swift (colors)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create pattern-based highlighter core</name>
  <files>Shared/SwiftPatternHighlighter.swift</files>
  <action>
Create a pure Swift pattern highlighter using character-by-character parsing (not regex for hot paths):

```swift
import Foundation
import SwiftUI

/// Fast pattern-based syntax highlighter
/// Uses character scanning instead of regex for performance
struct SwiftPatternHighlighter {

    struct Token {
        let text: String
        let type: TokenType
    }

    enum TokenType {
        case plain
        case keyword
        case string
        case comment
        case number
        case type
        case function
        case property
        case operator_
    }

    /// Language-specific patterns
    struct LanguagePatterns {
        let keywords: Set<String>
        let types: Set<String>
        let lineComment: String?      // e.g., "//" or "#"
        let blockCommentStart: String? // e.g., "/*"
        let blockCommentEnd: String?   // e.g., "*/"
        let stringDelimiters: [Character] // e.g., ['"', "'", "`"]
    }

    /// Tokenize code for a given language
    func tokenize(_ code: String, language: String) -> [Token] {
        let patterns = getPatterns(for: language)
        var tokens: [Token] = []
        var index = code.startIndex

        while index < code.endIndex {
            // Check for comments first
            if let token = tryParseComment(code, from: &index, patterns: patterns) {
                tokens.append(token)
                continue
            }

            // Check for strings
            if let token = tryParseString(code, from: &index, patterns: patterns) {
                tokens.append(token)
                continue
            }

            // Check for numbers
            if let token = tryParseNumber(code, from: &index) {
                tokens.append(token)
                continue
            }

            // Check for identifiers (keywords, types, etc.)
            if let token = tryParseIdentifier(code, from: &index, patterns: patterns) {
                tokens.append(token)
                continue
            }

            // Single character (operators, punctuation)
            let char = code[index]
            tokens.append(Token(text: String(char), type: .plain))
            index = code.index(after: index)
        }

        return tokens
    }

    // ... parsing helper methods
}
```

Key performance techniques (from shadowfacts article):
- Use String.UnicodeScalarView for fast character access
- Avoid creating substrings until token is complete
- No regex in hot paths
- Early exit on common cases
  </action>
  <verify>Unit tests for tokenization pass</verify>
  <done>Pattern highlighter core implemented</done>
</task>

<task type="auto">
  <name>Task 2: Add language patterns for top 20 languages</name>
  <files>Shared/SwiftPatternHighlighter.swift</files>
  <action>
Add pattern definitions for the most common languages in dotfiles:

Priority 1 (most common in dotfiles):
1. Shell/Bash - keywords: if, then, else, fi, for, do, done, case, esac, function, export, alias
2. JSON - structural only (strings, numbers, booleans, null)
3. YAML - keys, values, comments
4. INI/Properties - sections, keys, values, comments
5. Markdown - headers, code blocks, emphasis, links

Priority 2 (source code):
6. Swift - keywords, types, strings, comments
7. JavaScript - keywords, types, strings, template literals
8. TypeScript - same as JS + type annotations
9. Python - keywords, strings (including f-strings), comments
10. Go - keywords, types, strings, comments

Priority 3 (other common):
11. XML/HTML - tags, attributes, content
12. CSS - selectors, properties, values
13. SQL - keywords, strings, comments
14. Rust - keywords, types, lifetimes
15. C/C++ - keywords, preprocessor, strings
16. Java - keywords, annotations, strings
17. Ruby - keywords, symbols, strings
18. Dockerfile - instructions, arguments
19. Makefile - targets, variables, commands
20. GraphQL - keywords, types, fields

Each language needs:
- Keyword set
- Type set (for typed languages)
- Comment syntax
- String delimiters
- Special patterns (e.g., Ruby symbols, Python f-strings)
  </action>
  <verify>Test highlighting sample code for each language</verify>
  <done>20 language patterns implemented</done>
</task>

<task type="auto">
  <name>Task 3: Integrate with SyntaxHighlighter and test performance</name>
  <files>Shared/SyntaxHighlighter.swift</files>
  <action>
Replace/update SyntaxHighlighter to use SwiftPatternHighlighter:

```swift
actor SyntaxHighlighter {
    static let shared = SyntaxHighlighter()

    private let patternHighlighter = SwiftPatternHighlighter()

    func highlight(code: String, language: String?, theme: String = "github-dark") async -> AttributedString {
        let startTime = CFAbsoluteTimeGetCurrent()

        let lang = language ?? "plaintext"
        let tokens = patternHighlighter.tokenize(code, language: lang)
        let result = applyTheme(tokens: tokens, theme: theme)

        let elapsed = (CFAbsoluteTimeGetCurrent() - startTime) * 1000
        // Should be <10ms for typical files

        return result
    }

    private func applyTheme(tokens: [SwiftPatternHighlighter.Token], theme: String) -> AttributedString {
        let colors = ThemeManager.shared.colors(for: theme)
        var result = AttributedString()

        for token in tokens {
            var attrs = AttributeContainer()
            attrs.foregroundColor = colorFor(token.type, colors: colors)

            var tokenAttr = AttributedString(token.text)
            tokenAttr.mergeAttributes(attrs)
            result.append(tokenAttr)
        }

        return result
    }
}
```

Remove Syntect/UniFFI dependencies if they were the problem.

Performance target: <10ms for 1000 lines
  </action>
  <verify>
1. Build succeeds
2. Console logs show <10ms highlighting times
3. Rapid navigation test at 140 BPM feels instant
  </verify>
  <done>Pattern highlighter integrated and performance verified</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] All 20 languages tokenize correctly
- [ ] Performance: <10ms for typical files
- [ ] 140 BPM navigation feels instant
- [ ] Visual quality acceptable (not perfect, but good)
</verification>

<success_criteria>
- Pure Swift implementation, no external dependencies
- Instant performance (<10ms)
- Top 20 languages covered
- Acceptable highlighting quality for dotfile viewing
</success_criteria>

<output>
After completion, create `.planning/phases/03-performance/03-04-SUMMARY.md`
</output>
