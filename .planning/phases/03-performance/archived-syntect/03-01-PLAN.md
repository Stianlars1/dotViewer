---
phase: 03-performance
plan: 01
type: execute
wave: 1
depends_on: []
files_modified: [syntect-swift/src/lib.rs, syntect-swift/Cargo.toml, syntect-swift/uniffi.toml]
autonomous: true
---

<objective>
Set up Syntect Rust library with UniFFI bindings for Swift integration.

Purpose: Create a high-performance syntax highlighting engine using Syntect (Rust) that can be called from Swift via UniFFI-generated bindings.
Output: A Rust library that exposes syntax highlighting functionality via UniFFI, ready to be built into an XCFramework.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

Reference documentation:
- Syntect: https://github.com/trishume/syntect
- UniFFI: https://github.com/mozilla/uniffi-rs
- cargo-swift: https://github.com/nicklockwood/cargo-swift

@Shared/SyntaxHighlighter.swift (current implementation to replace)
@Shared/ThemeManager.swift (theme colors to map)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create Rust project with Syntect and UniFFI</name>
  <files>syntect-swift/Cargo.toml, syntect-swift/src/lib.rs, syntect-swift/uniffi.toml</files>
  <action>
Create a new Rust library project in the repository root:

```bash
mkdir -p syntect-swift
cd syntect-swift
cargo init --lib
```

Set up Cargo.toml with:
- syntect with default-syntaxes and default-themes features
- uniffi for Swift bindings generation
- lib type as cdylib + staticlib

Create src/lib.rs with a simple API:
```rust
use syntect::highlighting::{ThemeSet, Style};
use syntect::parsing::SyntaxSet;
use syntect::easy::HighlightLines;

#[derive(uniffi::Record)]
pub struct HighlightedSpan {
    pub text: String,
    pub foreground: String,  // hex color like "#FF0000"
    pub background: String,
    pub font_style: u8,      // 0=normal, 1=bold, 2=italic, 3=bold+italic
}

#[derive(uniffi::Record)]
pub struct HighlightResult {
    pub spans: Vec<HighlightedSpan>,
    pub background: String,
}

#[uniffi::export]
pub fn highlight_code(code: &str, language: &str, theme: &str) -> HighlightResult {
    // Load syntax set (bundled via default-syntaxes)
    // Load theme set (bundled via default-themes)
    // Find syntax by language name/extension
    // Highlight and return spans with colors
}

#[uniffi::export]
pub fn get_available_languages() -> Vec<String> {
    // Return list of supported language names
}

#[uniffi::export]
pub fn get_available_themes() -> Vec<String> {
    // Return list of theme names
}

uniffi::setup_scaffolding!();
```

Create uniffi.toml for Swift binding configuration.
  </action>
  <verify>
```bash
cd syntect-swift && cargo check
```
Compiles without errors.
  </verify>
  <done>Rust project created with Syntect and UniFFI configured</done>
</task>

<task type="auto">
  <name>Task 2: Implement highlighting function with theme support</name>
  <files>syntect-swift/src/lib.rs</files>
  <action>
Implement the full highlighting logic:

1. Use lazy_static or once_cell to load SyntaxSet and ThemeSet once
2. Implement language lookup by:
   - Exact name match
   - Extension match (e.g., "swift" -> Swift syntax)
   - Fallback to plain text
3. Convert Syntect's Style to hex colors for Swift consumption
4. Handle the "base16-ocean.dark" theme as default (matches current app theme)
5. Add error handling for unknown languages (fallback to plain text)

Key implementation details:
- Use `syntect::dumps::from_binary` for fast loading of pre-compiled syntaxes
- Convert RGBA colors to hex strings: format!("#{:02X}{:02X}{:02X}", r, g, b)
- Map font_style: BOLD=1, ITALIC=2, UNDERLINE=4 (use bitflags)

Performance targets:
- First call: <100ms (loading syntaxes)
- Subsequent calls: <50ms for 1000 lines
  </action>
  <verify>
```bash
cd syntect-swift && cargo test
```
Write a simple test that highlights "fn main() {}" as Rust and verifies spans are returned.
  </verify>
  <done>Highlighting function fully implemented with theme support</done>
</task>

<task type="auto">
  <name>Task 3: Add theme mapping for dotViewer compatibility</name>
  <files>syntect-swift/src/lib.rs</files>
  <action>
Map dotViewer's existing theme names to Syntect themes:

dotViewer themes (from ThemeManager.swift):
- "a11y-dark" -> Map to closest Syntect theme
- "github-dark" -> "base16-ocean.dark" or similar
- "monokai" -> "Monokai Extended" if available
- etc.

Create a theme mapping function:
```rust
fn map_theme_name(app_theme: &str) -> &str {
    match app_theme {
        "a11y-dark" => "base16-ocean.dark",
        "github-dark" => "base16-ocean.dark",
        "monokai" => "Monokai Extended",
        _ => "base16-ocean.dark"  // fallback
    }
}
```

Also add function to get theme background color for the overall view.
  </action>
  <verify>cargo test with theme mapping tests</verify>
  <done>Theme mapping implemented for dotViewer compatibility</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] `cargo check` passes
- [ ] `cargo test` passes
- [ ] `cargo build --release` produces library
- [ ] Highlighting produces correct colored spans for Swift code
</verification>

<success_criteria>
- Rust library compiles successfully
- highlight_code() returns colored spans
- Theme mapping covers dotViewer themes
- Tests pass for basic highlighting scenarios
</success_criteria>

<output>
After completion, create `.planning/phases/03-performance/03-01-SUMMARY.md`
</output>
