---
phase: 03-performance
plan: 03
type: execute
wave: 2
depends_on: ["03-01"]
files_modified: [Shared/SyntaxHighlighter.swift, dotViewer.xcodeproj/project.pbxproj]
autonomous: false
---

<objective>
Evaluate faster syntax highlighting alternatives and implement the best option to reduce highlighting time from 1-2s to <200ms.

Purpose: Even with lazy loading (03-02), faster highlighting improves perceived responsiveness and reduces battery/CPU usage.
Output: SyntaxHighlighter using faster backend (native C++ or Swift regex approach).
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
@~/.claude/get-shit-done/references/checkpoints.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-performance/03-01-SUMMARY.md

@Shared/SyntaxHighlighter.swift
@Shared/ThemeManager.swift
</context>

<tasks>

<task type="auto">
  <name>Task 1: Research and prototype faster highlighting approach</name>
  <files>Shared/SyntaxHighlighterFast.swift</files>
  <action>
Create a prototype fast highlighter using one of these approaches (evaluate in order):

**Option A: Pure Swift regex (like CodeColors)**
- Implement basic patterns for top languages: Swift, JS/TS, Python, Go, Rust, Shell, JSON, YAML
- Use NSRegularExpression for speed
- Simple pattern matching: keywords, strings, comments, numbers
- Pro: No dependencies, instant. Con: Less accurate, limited languages.

**Option B: Tree-sitter via swift-tree-sitter**
- Use tree-sitter grammars for accurate parsing
- Pro: Very accurate, fast (native). Con: Need to bundle grammars, adds complexity.

**Option C: Evaluate andre-simon Highlight**
- Check if it can be embedded (C++ library)
- Pro: 200+ languages, native speed. Con: C++ interop complexity.

Prototype the simplest viable solution (likely Option A for Swift/common languages):

```swift
struct SyntaxHighlighterFast {
    func highlight(code: String, language: String?) -> AttributedString {
        // Pattern-based highlighting for common languages
        // Fall back to plain text for unsupported languages
    }
}
```

Focus on the languages most commonly previewed in dotfiles/dev work:
1. Shell/Bash (most dotfiles)
2. JSON/YAML (config files)
3. Swift/JS/TS/Python (source code)
  </action>
  <verify>New highlighter compiles and produces colored output for test input</verify>
  <done>Fast highlighter prototype created with basic pattern support</done>
</task>

<task type="checkpoint:decision" gate="blocking">
  <decision>Choose syntax highlighting approach based on prototype results</decision>
  <context>
After Task 1 prototyping, decide which approach to use for production:
- Pure Swift regex is simplest but may have limited language support
- Tree-sitter is most accurate but adds bundle size
- Keeping HighlightSwift for accuracy with lazy loading (03-02) may be sufficient
  </context>
  <options>
    <option id="swift-regex">
      <name>Pure Swift regex highlighter</name>
      <pros>Instant performance, no dependencies, simple code</pros>
      <cons>Limited language coverage, less accurate highlighting</cons>
    </option>
    <option id="tree-sitter">
      <name>Tree-sitter integration</name>
      <pros>Very accurate, native speed, proper AST parsing</pros>
      <cons>Complex integration, grammar files add bundle size</cons>
    </option>
    <option id="keep-current">
      <name>Keep HighlightSwift with lazy loading only</name>
      <pros>Already works, 185+ languages, no changes needed</pros>
      <cons>Still 1-2s highlight time (but hidden by lazy loading)</cons>
    </option>
  </options>
  <resume-signal>Select: swift-regex, tree-sitter, or keep-current</resume-signal>
</task>

<task type="auto">
  <name>Task 2: Implement chosen highlighting approach</name>
  <files>Shared/SyntaxHighlighter.swift</files>
  <action>
Based on checkpoint decision:

**If swift-regex selected:**
- Replace SyntaxHighlighter internals with pattern-based approach
- Keep async interface for API compatibility
- Remove HighlightSwift dependency from Package.swift
- Test with shell scripts, JSON, YAML, Swift files

**If tree-sitter selected:**
- Add swift-tree-sitter dependency
- Bundle required grammar files
- Implement grammar loading and parsing
- Map parsed tree to AttributedString

**If keep-current selected:**
- Document decision in SUMMARY
- No code changes needed (03-02 handles perceived performance)
- Keep HighlightSwift for accuracy

Maintain existing API surface: `func highlight(code: String, language: String?) async throws -> AttributedString`
  </action>
  <verify>
Build succeeds and highlighting produces correct output for:
- .bashrc (shell)
- package.json (JSON)
- .swift file (Swift)
  </verify>
  <done>Chosen highlighting approach implemented and tested</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] Fast highlighter prototype tested
- [ ] Decision made with user input
- [ ] Chosen approach implemented
- [ ] Common file types highlight correctly
</verification>

<success_criteria>
- Highlighting time reduced (target: <200ms for 20KB file) OR documented decision to keep current with lazy loading
- Common languages supported: Shell, JSON, YAML, Swift, JS/TS, Python
- Existing theme support maintained
- No regression in highlighting quality for supported languages
</success_criteria>

<output>
After completion, create `.planning/phases/03-performance/03-03-SUMMARY.md`
</output>
